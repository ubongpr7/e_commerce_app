{"version":3,"file":"index.cjs","sources":["../src/editor-event-listener.tsx","../src/internal-utils/compound-client-rect.ts","../src/internal-utils/drag-selection.ts","../src/internal-utils/event-position.ts","../src/internal-utils/selection.ts","../src/internal-utils/selection-elements.ts","../src/editor/components/DefaultObject.tsx","../src/editor/components/drop-indicator.tsx","../src/editor/components/Element.tsx","../src/editor/components/Leaf.tsx","../src/editor/plugins/createWithHotKeys.ts","../src/editor/range-decorations-machine.ts","../src/editor/Editable.tsx"],"sourcesContent":["import {useEffect} from 'react'\nimport {useEffectEvent} from 'use-effect-event'\nimport type {EditorEmittedEvent} from './editor/editor-machine'\nimport {useEditor} from './editor/editor-provider'\n\n/**\n * @public\n * @deprecated\n * This component has been renamed. Use `EventListenerPlugin` instead.\n *\n * ```\n * import {EventListenerPlugin} from '@portabletext/editor/plugins'\n * ```\n */\nexport function EditorEventListener(props: {\n  on: (event: EditorEmittedEvent) => void\n}) {\n  const editor = useEditor()\n  const on = useEffectEvent(props.on)\n\n  useEffect(() => {\n    const subscription = editor.on('*', on)\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [editor])\n\n  return null\n}\n","export function getCompoundClientRect(nodes: Array<Node>): DOMRect {\n  if (nodes.length === 0) {\n    return new DOMRect(0, 0, 0, 0)\n  }\n\n  const elements = nodes.filter((node) => node instanceof Element)\n\n  const firstRect = elements.at(0)?.getBoundingClientRect()\n\n  if (!firstRect) {\n    return new DOMRect(0, 0, 0, 0)\n  }\n\n  let left = firstRect.left\n  let top = firstRect.top\n  let right = firstRect.right\n  let bottom = firstRect.bottom\n\n  for (let i = 1; i < elements.length; i++) {\n    const rect = elements[i].getBoundingClientRect()\n    left = Math.min(left, rect.left)\n    top = Math.min(top, rect.top)\n    right = Math.max(right, rect.right)\n    bottom = Math.max(bottom, rect.bottom)\n  }\n\n  return new DOMRect(left, top, right - left, bottom - top)\n}\n","import type {EditorSnapshot} from '..'\nimport * as selectors from '../selectors'\nimport * as utils from '../utils'\nimport type {EventPosition} from './event-position'\n\n/**\n * Given the current editor `snapshot` and an `eventSelection` representing\n * where the drag event origins from, this function calculates the selection\n * in the editor that should be dragged.\n */\nexport function getDragSelection({\n  eventSelection,\n  snapshot,\n}: {\n  eventSelection: EventPosition['selection']\n  snapshot: EditorSnapshot\n}) {\n  let dragSelection = eventSelection\n\n  const draggedInlineObject = selectors.getFocusInlineObject({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n\n  if (draggedInlineObject) {\n    return dragSelection\n  }\n\n  const draggingCollapsedSelection = selectors.isSelectionCollapsed({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n  const draggedTextBlock = selectors.getFocusTextBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n  const draggedSpan = selectors.getFocusSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n\n  if (draggingCollapsedSelection && draggedTextBlock && draggedSpan) {\n    // Looks like we are dragging an empty span\n    // Let's drag the entire block instead\n    dragSelection = {\n      anchor: utils.getBlockStartPoint(draggedTextBlock),\n      focus: utils.getBlockEndPoint(draggedTextBlock),\n    }\n  }\n\n  const selectedBlocks = selectors.getSelectedBlocks(snapshot)\n\n  if (\n    snapshot.context.selection &&\n    selectors.isSelectionExpanded(snapshot) &&\n    selectedBlocks.length > 1\n  ) {\n    const selectionStartBlock = selectors.getSelectionStartBlock(snapshot)\n    const selectionEndBlock = selectors.getSelectionEndBlock(snapshot)\n\n    if (!selectionStartBlock || !selectionEndBlock) {\n      return dragSelection\n    }\n\n    const selectionStartPoint = utils.getBlockStartPoint(selectionStartBlock)\n    const selectionEndPoint = utils.getBlockEndPoint(selectionEndBlock)\n\n    const eventSelectionInsideBlocks = selectors.isOverlappingSelection(\n      eventSelection,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {anchor: selectionStartPoint, focus: selectionEndPoint},\n      },\n    })\n\n    if (eventSelectionInsideBlocks) {\n      dragSelection = {\n        anchor: selectionStartPoint,\n        focus: selectionEndPoint,\n      }\n    }\n  }\n\n  return dragSelection\n}\n","import {Editor, type BaseRange, type Node} from 'slate'\nimport {DOMEditor, isDOMNode} from 'slate-dom'\nimport type {EditorSchema, EditorSelection} from '..'\nimport type {EditorActor} from '../editor/editor-machine'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport * as utils from '../utils'\nimport {\n  getFirstBlock,\n  getLastBlock,\n  getNodeBlock,\n  slateRangeToSelection,\n} from './slate-utils'\n\nexport type EventPosition = {\n  block: 'start' | 'end'\n  /**\n   * Did the event origin from the editor DOM node itself or from a child node?\n   */\n  isEditor: boolean\n  selection: NonNullable<EditorSelection>\n}\nexport type EventPositionBlock = EventPosition['block']\n\nexport function getEventPosition({\n  editorActor,\n  slateEditor,\n  event,\n}: {\n  editorActor: EditorActor\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EventPosition | undefined {\n  if (editorActor.getSnapshot().matches({setup: 'setting up'})) {\n    return undefined\n  }\n\n  const node = getEventNode({slateEditor, event})\n\n  if (!node) {\n    return undefined\n  }\n\n  const block = getNodeBlock({\n    editor: slateEditor,\n    schema: editorActor.getSnapshot().context.schema,\n    node,\n  })\n\n  const positionBlock = getEventPositionBlock({node, slateEditor, event})\n  const selection = getEventSelection({\n    schema: editorActor.getSnapshot().context.schema,\n    slateEditor,\n    event,\n  })\n\n  if (block && positionBlock && !selection && !Editor.isEditor(node)) {\n    return {\n      block: positionBlock,\n      isEditor: false,\n      selection: {\n        anchor: utils.getBlockStartPoint({\n          node: block,\n          path: [{_key: block._key}],\n        }),\n        focus: utils.getBlockEndPoint({\n          node: block,\n          path: [{_key: block._key}],\n        }),\n      },\n    }\n  }\n\n  if (!positionBlock || !selection) {\n    return undefined\n  }\n\n  const focusBlockPath = selection.focus.path.at(0)\n  const focusBlockKey = utils.isKeyedSegment(focusBlockPath)\n    ? focusBlockPath._key\n    : undefined\n\n  if (!focusBlockKey) {\n    return undefined\n  }\n\n  if (\n    utils.isSelectionCollapsed(selection) &&\n    block &&\n    focusBlockKey !== block._key\n  ) {\n    return {\n      block: positionBlock,\n      isEditor: false,\n      selection: {\n        anchor: utils.getBlockStartPoint({\n          node: block,\n          path: [{_key: block._key}],\n        }),\n        focus: utils.getBlockEndPoint({\n          node: block,\n          path: [{_key: block._key}],\n        }),\n      },\n    }\n  }\n\n  return {\n    block: positionBlock,\n    isEditor: Editor.isEditor(node),\n    selection,\n  }\n}\n\nexport function getEventNode({\n  slateEditor,\n  event,\n}: {\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}) {\n  if (!DOMEditor.hasTarget(slateEditor, event.target)) {\n    return undefined\n  }\n\n  const node = DOMEditor.toSlateNode(slateEditor, event.target)\n\n  return node\n}\n\nfunction getEventPositionBlock({\n  node,\n  slateEditor,\n  event,\n}: {\n  node: Node\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EventPositionBlock | undefined {\n  const [firstBlock] = getFirstBlock({editor: slateEditor})\n\n  if (!firstBlock) {\n    return undefined\n  }\n\n  const firstBlockElement = DOMEditor.toDOMNode(slateEditor, firstBlock)\n  const firstBlockRect = firstBlockElement.getBoundingClientRect()\n\n  if (event.pageY < firstBlockRect.top) {\n    return 'start'\n  }\n\n  const [lastBlock] = getLastBlock({editor: slateEditor})\n\n  if (!lastBlock) {\n    return undefined\n  }\n\n  const lastBlockElement = DOMEditor.toDOMNode(slateEditor, lastBlock)\n  const lastBlockRef = lastBlockElement.getBoundingClientRect()\n\n  if (event.pageY > lastBlockRef.bottom) {\n    return 'end'\n  }\n\n  const element = DOMEditor.toDOMNode(slateEditor, node)\n  const elementRect = element.getBoundingClientRect()\n  const top = elementRect.top\n  const height = elementRect.height\n  const location = Math.abs(top - event.pageY)\n\n  return location < height / 2 ? 'start' : 'end'\n}\n\nexport function getEventSelection({\n  schema,\n  slateEditor,\n  event,\n}: {\n  schema: EditorSchema\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EditorSelection {\n  const range = getSlateRangeFromEvent(slateEditor, event)\n\n  const selection = range\n    ? slateRangeToSelection({\n        schema,\n        editor: slateEditor,\n        range,\n      })\n    : null\n\n  return selection\n}\n\nfunction getSlateRangeFromEvent(\n  editor: PortableTextSlateEditor,\n  event: DragEvent | MouseEvent,\n) {\n  if (!event.target) {\n    return undefined\n  }\n\n  if (!isDOMNode(event.target)) {\n    return undefined\n  }\n\n  const window = DOMEditor.getWindow(editor)\n\n  let domRange: Range | undefined\n\n  if (window.document.caretPositionFromPoint !== undefined) {\n    const position = window.document.caretPositionFromPoint(\n      event.clientX,\n      event.clientY,\n    )\n\n    if (position) {\n      try {\n        domRange = window.document.createRange()\n        domRange.setStart(position.offsetNode, position.offset)\n        domRange.setEnd(position.offsetNode, position.offset)\n      } catch {}\n    }\n  } else if (window.document.caretRangeFromPoint !== undefined) {\n    // Use WebKit-proprietary fallback method\n    domRange =\n      window.document.caretRangeFromPoint(event.clientX, event.clientY) ??\n      undefined\n  } else {\n    console.warn(\n      'Neither caretPositionFromPoint nor caretRangeFromPoint is supported',\n    )\n    return undefined\n  }\n\n  if (!domRange) {\n    return undefined\n  }\n\n  let range: BaseRange | undefined\n\n  try {\n    range = DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      // It can still throw even with this option set to true\n      suppressThrow: false,\n    })\n  } catch {}\n\n  return range\n}\n","import type {Path, PortableTextBlock} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport type {EditorSelection, EditorSelectionPoint} from '../types/editor'\n\nexport function normalizePoint(\n  point: EditorSelectionPoint,\n  value: PortableTextBlock[],\n): EditorSelectionPoint | null {\n  if (!point || !value) {\n    return null\n  }\n  const newPath: Path = []\n  let newOffset: number = point.offset || 0\n  const blockKey =\n    typeof point.path[0] === 'object' &&\n    '_key' in point.path[0] &&\n    point.path[0]._key\n  const childKey =\n    typeof point.path[2] === 'object' &&\n    '_key' in point.path[2] &&\n    point.path[2]._key\n  const block: PortableTextBlock | undefined = value.find(\n    (blk) => blk._key === blockKey,\n  )\n  if (block) {\n    newPath.push({_key: block._key})\n  } else {\n    return null\n  }\n  if (block && point.path[1] === 'children') {\n    if (\n      !block.children ||\n      (Array.isArray(block.children) && block.children.length === 0)\n    ) {\n      return null\n    }\n    const child =\n      Array.isArray(block.children) &&\n      block.children.find((cld) => cld._key === childKey)\n    if (child) {\n      newPath.push('children')\n      newPath.push({_key: child._key})\n      newOffset =\n        child.text && child.text.length >= point.offset\n          ? point.offset\n          : (child.text && child.text.length) || 0\n    } else {\n      return null\n    }\n  }\n  return {path: newPath, offset: newOffset}\n}\n\nexport function normalizeSelection(\n  selection: EditorSelection,\n  value: PortableTextBlock[] | undefined,\n): EditorSelection | null {\n  if (!selection || !value || value.length === 0) {\n    return null\n  }\n  let newAnchor: EditorSelectionPoint | null = null\n  let newFocus: EditorSelectionPoint | null = null\n  const {anchor, focus} = selection\n  if (\n    anchor &&\n    value.find((blk) => isEqual({_key: blk._key}, anchor.path[0]))\n  ) {\n    newAnchor = normalizePoint(anchor, value)\n  }\n  if (focus && value.find((blk) => isEqual({_key: blk._key}, focus.path[0]))) {\n    newFocus = normalizePoint(focus, value)\n  }\n  if (newAnchor && newFocus) {\n    return {anchor: newAnchor, focus: newFocus, backward: selection.backward}\n  }\n  return null\n}\n","import {Editor} from 'slate'\nimport {DOMEditor} from 'slate-dom'\nimport type {EditorSnapshot} from '..'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport {toSlateRange} from './ranges'\n\nexport type SelectionDomNodes = {\n  blockNodes: Array<Node>\n  childNodes: Array<Node>\n}\n\nexport function getSelectionDomNodes({\n  slateEditor,\n  snapshot,\n}: {\n  slateEditor: PortableTextSlateEditor\n  snapshot: EditorSnapshot\n}): SelectionDomNodes {\n  if (!snapshot.context.selection) {\n    return {\n      blockNodes: [],\n      childNodes: [],\n    }\n  }\n\n  const range = toSlateRange(snapshot.context.selection, slateEditor)\n\n  if (!range) {\n    return {\n      blockNodes: [],\n      childNodes: [],\n    }\n  }\n\n  const blockEntries = Array.from(\n    Editor.nodes(slateEditor, {\n      at: range,\n      mode: 'highest',\n      match: (n) => !Editor.isEditor(n),\n    }),\n  )\n\n  const childEntries = Array.from(\n    Editor.nodes(slateEditor, {\n      at: range,\n      mode: 'lowest',\n      match: (n) =>\n        (!Editor.isEditor(n) && slateEditor.isTextSpan(n)) ||\n        !slateEditor.isBlock(n),\n    }),\n  )\n\n  return {\n    blockNodes: blockEntries.map(([blockNode]) =>\n      DOMEditor.toDOMNode(slateEditor, blockNode),\n    ),\n    childNodes: childEntries.map(([childNode]) =>\n      DOMEditor.toDOMNode(slateEditor, childNode),\n    ),\n  }\n}\n","import type {PortableTextBlock, PortableTextChild} from '@sanity/types'\n\nexport function DefaultBlockObject(props: {\n  value: PortableTextBlock | PortableTextChild\n}) {\n  return (\n    <div style={{userSelect: 'none'}}>\n      [{props.value._type}: {props.value._key}]\n    </div>\n  )\n}\n\nexport function DefaultInlineObject(props: {\n  value: PortableTextBlock | PortableTextChild\n}) {\n  return (\n    <span style={{userSelect: 'none'}}>\n      [{props.value._type}: {props.value._key}]\n    </span>\n  )\n}\n","export function DropIndicator() {\n  return (\n    <div\n      contentEditable={false}\n      className=\"pt-drop-indicator\"\n      style={{\n        position: 'absolute',\n        width: '100%',\n        height: 1,\n        borderBottom: '1px solid currentColor',\n        zIndex: 5,\n      }}\n    >\n      <span />\n    </div>\n  )\n}\n","import type {\n  Path,\n  PortableTextChild,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type FunctionComponent,\n  type JSX,\n  type ReactElement,\n} from 'react'\nimport {Editor, Range, Element as SlateElement} from 'slate'\nimport {\n  ReactEditor,\n  useSelected,\n  useSlateStatic,\n  type RenderElementProps,\n} from 'slate-react'\nimport {defineBehavior} from '../../behaviors'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {EventPositionBlock} from '../../internal-utils/event-position'\nimport {fromSlateValue} from '../../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../../internal-utils/weakMaps'\nimport * as selectors from '../../selectors'\nimport type {\n  BlockRenderProps,\n  PortableTextMemberSchemaTypes,\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderListItemFunction,\n  RenderStyleFunction,\n} from '../../types/editor'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {DefaultBlockObject, DefaultInlineObject} from './DefaultObject'\nimport {DropIndicator} from './drop-indicator'\n\nconst debug = debugWithName('components:Element')\nconst debugRenders = false\nconst EMPTY_ANNOTATIONS: PortableTextObject[] = []\n\n/**\n * @internal\n */\nexport interface ElementProps {\n  attributes: RenderElementProps['attributes']\n  children: ReactElement<any>\n  element: SlateElement\n  schemaTypes: PortableTextMemberSchemaTypes\n  readOnly: boolean\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderListItem?: RenderListItemFunction\n  renderStyle?: RenderStyleFunction\n  spellCheck?: boolean\n}\n\nconst inlineBlockStyle = {display: 'inline-block'}\n\n/**\n * Renders Portable Text block and inline object nodes in Slate\n * @internal\n */\nexport const Element: FunctionComponent<ElementProps> = ({\n  attributes,\n  children,\n  element,\n  schemaTypes,\n  readOnly,\n  renderBlock,\n  renderChild,\n  renderListItem,\n  renderStyle,\n  spellCheck,\n}) => {\n  const editorActor = useContext(EditorActorContext)\n  const slateEditor = useSlateStatic()\n  const selected = useSelected()\n  const blockRef = useRef<HTMLDivElement | null>(null)\n  const inlineBlockObjectRef = useRef(null)\n  const focused =\n    (selected &&\n      slateEditor.selection &&\n      Range.isCollapsed(slateEditor.selection)) ||\n    false\n  const [dragPositionBlock, setDragPositionBlock] =\n    useState<EventPositionBlock>()\n\n  useEffect(() => {\n    const behavior = defineBehavior({\n      on: 'drag.dragover',\n      guard: ({snapshot, event}) => {\n        const dropFocusBlock = selectors.getFocusBlock({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: event.position.selection,\n          },\n        })\n\n        if (!dropFocusBlock || dropFocusBlock.node._key !== element._key) {\n          return false\n        }\n\n        const dragOrigin = snapshot.beta.internalDrag?.origin\n\n        if (!dragOrigin) {\n          return false\n        }\n\n        const draggedBlocks = selectors.getSelectedBlocks({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragOrigin.selection,\n          },\n        })\n\n        if (\n          draggedBlocks.some(\n            (draggedBlock) => draggedBlock.node._key === element._key,\n          )\n        ) {\n          return false\n        }\n\n        const draggingEntireBlocks = selectors.isSelectingEntireBlocks({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragOrigin.selection,\n          },\n        })\n\n        return draggingEntireBlocks\n      },\n      actions: [\n        ({event}) => [\n          {\n            type: 'effect',\n            effect: () => {\n              setDragPositionBlock(event.position.block)\n            },\n          },\n          {\n            type: 'noop',\n          },\n        ],\n      ],\n    })\n\n    editorActor.send({\n      type: 'add behavior',\n      behavior,\n    })\n\n    return () => {\n      editorActor.send({\n        type: 'remove behavior',\n        behavior,\n      })\n    }\n  }, [editorActor, element._key])\n\n  useEffect(() => {\n    const behavior = defineBehavior({\n      on: 'drag.*',\n      guard: ({event}) => {\n        return event.type !== 'drag.dragover'\n      },\n      actions: [\n        () => [\n          {\n            type: 'effect',\n            effect: () => {\n              setDragPositionBlock(undefined)\n            },\n          },\n        ],\n      ],\n    })\n\n    editorActor.send({\n      type: 'add behavior',\n      behavior,\n    })\n\n    return () => {\n      editorActor.send({\n        type: 'remove behavior',\n        behavior,\n      })\n    }\n  }, [editorActor])\n\n  const value = useMemo(\n    () =>\n      fromSlateValue(\n        [element],\n        schemaTypes.block.name,\n        KEY_TO_VALUE_ELEMENT.get(slateEditor),\n      )[0],\n    [slateEditor, element, schemaTypes.block.name],\n  )\n\n  let renderedBlock = children\n\n  let className: string | undefined\n\n  const blockPath: Path = useMemo(() => [{_key: element._key}], [element])\n\n  if (typeof element._type !== 'string') {\n    throw new Error(`Expected element to have a _type property`)\n  }\n\n  if (typeof element._key !== 'string') {\n    throw new Error(`Expected element to have a _key property`)\n  }\n\n  // Test for inline objects first\n  if (slateEditor.isInline(element)) {\n    const path = ReactEditor.findPath(slateEditor, element)\n    const [block] = Editor.node(slateEditor, path, {depth: 1})\n    const schemaType = schemaTypes.inlineObjects.find(\n      (_type) => _type.name === element._type,\n    )\n    if (!schemaType) {\n      throw new Error('Could not find type for inline block element')\n    }\n    if (SlateElement.isElement(block)) {\n      const elmPath: Path = [\n        {_key: block._key},\n        'children',\n        {_key: element._key},\n      ]\n      if (debugRenders) {\n        debug(`Render ${element._key} (inline object)`)\n      }\n      return (\n        <span {...attributes}>\n          {/* Note that children must follow immediately or cut and selections will not work properly in Chrome. */}\n          {children}\n          <span\n            draggable={!readOnly}\n            className=\"pt-inline-object\"\n            data-testid=\"pt-inline-object\"\n            ref={inlineBlockObjectRef}\n            key={element._key}\n            style={inlineBlockStyle}\n            contentEditable={false}\n          >\n            {renderChild &&\n              renderChild({\n                annotations: EMPTY_ANNOTATIONS, // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.\n                children: <DefaultInlineObject value={value} />,\n                editorElementRef: inlineBlockObjectRef,\n                focused,\n                path: elmPath,\n                schemaType,\n                selected,\n                type: schemaType,\n                value: value as PortableTextChild,\n              })}\n            {!renderChild && <DefaultInlineObject value={value} />}\n          </span>\n        </span>\n      )\n    }\n    throw new Error('Block not found!')\n  }\n\n  // If not inline, it's either a block (text) or a block object (non-text)\n  // NOTE: text blocks aren't draggable with DraggableBlock (yet?)\n  if (element._type === schemaTypes.block.name) {\n    className = `pt-block pt-text-block`\n    const isListItem = 'listItem' in element\n    if (debugRenders) {\n      debug(`Render ${element._key} (text block)`)\n    }\n    const style = ('style' in element && element.style) || 'normal'\n    className = `pt-block pt-text-block pt-text-block-style-${style}`\n    const blockStyleType = schemaTypes.styles.find(\n      (item) => item.value === style,\n    )\n    if (renderStyle && blockStyleType) {\n      renderedBlock = renderStyle({\n        block: element as PortableTextTextBlock,\n        children,\n        focused,\n        selected,\n        value: style,\n        path: blockPath,\n        schemaType: blockStyleType,\n        editorElementRef: blockRef,\n      })\n    }\n    let level: number | undefined\n\n    if (isListItem) {\n      if (typeof element.level === 'number') {\n        level = element.level\n      }\n      className += ` pt-list-item pt-list-item-${element.listItem} pt-list-item-level-${level || 1}`\n    }\n\n    if (slateEditor.isListBlock(value) && isListItem && element.listItem) {\n      const listType = schemaTypes.lists.find(\n        (item) => item.value === element.listItem,\n      )\n      if (renderListItem && listType) {\n        renderedBlock = renderListItem({\n          block: value,\n          children: renderedBlock,\n          focused,\n          selected,\n          value: element.listItem,\n          path: blockPath,\n          schemaType: listType,\n          level: value.level || 1,\n          editorElementRef: blockRef,\n        })\n      }\n    }\n\n    const renderProps: Omit<BlockRenderProps, 'type'> = Object.defineProperty(\n      {\n        children: renderedBlock,\n        editorElementRef: blockRef,\n        focused,\n        level,\n        listItem: isListItem ? element.listItem : undefined,\n        path: blockPath,\n        selected,\n        style,\n        schemaType: schemaTypes.block,\n        value,\n      },\n      'type',\n      {\n        enumerable: false,\n        get() {\n          console.warn(\n            \"Property 'type' is deprecated, use 'schemaType' instead.\",\n          )\n          return schemaTypes.block\n        },\n      },\n    )\n\n    const propsOrDefaultRendered = renderBlock\n      ? renderBlock(renderProps as BlockRenderProps)\n      : children\n\n    return (\n      <div\n        key={element._key}\n        {...attributes}\n        className={className}\n        spellCheck={spellCheck}\n      >\n        {dragPositionBlock === 'start' ? <DropIndicator /> : null}\n        <div ref={blockRef}>{propsOrDefaultRendered}</div>\n        {dragPositionBlock === 'end' ? <DropIndicator /> : null}\n      </div>\n    )\n  }\n\n  const schemaType = schemaTypes.blockObjects.find(\n    (_type) => _type.name === element._type,\n  )\n\n  if (!schemaType) {\n    throw new Error(\n      `Could not find schema type for block element of _type ${element._type}`,\n    )\n  }\n\n  if (debugRenders) {\n    debug(`Render ${element._key} (object block)`)\n  }\n\n  className = 'pt-block pt-object-block'\n\n  const block = fromSlateValue(\n    [element],\n    schemaTypes.block.name,\n    KEY_TO_VALUE_ELEMENT.get(slateEditor),\n  )[0]\n\n  let renderedBlockFromProps: JSX.Element | undefined\n\n  if (renderBlock) {\n    const _props: Omit<BlockRenderProps, 'type'> = Object.defineProperty(\n      {\n        children: <DefaultBlockObject value={value} />,\n        editorElementRef: blockRef,\n        focused,\n        path: blockPath,\n        schemaType,\n        selected,\n        value: block,\n      },\n      'type',\n      {\n        enumerable: false,\n        get() {\n          console.warn(\n            \"Property 'type' is deprecated, use 'schemaType' instead.\",\n          )\n          return schemaType\n        },\n      },\n    )\n    renderedBlockFromProps = renderBlock(_props as BlockRenderProps)\n  }\n\n  return (\n    <div key={element._key} {...attributes} className={className}>\n      {dragPositionBlock === 'start' ? <DropIndicator /> : null}\n      {children}\n      <div ref={blockRef} contentEditable={false} draggable={!readOnly}>\n        {renderedBlockFromProps ? (\n          renderedBlockFromProps\n        ) : (\n          <DefaultBlockObject value={value} />\n        )}\n      </div>\n      {dragPositionBlock === 'end' ? <DropIndicator /> : null}\n    </div>\n  )\n}\n\nElement.displayName = 'Element'\n","import type {\n  Path,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {isEqual, uniq} from 'lodash'\nimport {\n  startTransition,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type ReactElement,\n} from 'react'\nimport {Text} from 'slate'\nimport {useSelected, type RenderLeafProps} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {\n  BlockAnnotationRenderProps,\n  BlockChildRenderProps,\n  BlockDecoratorRenderProps,\n  PortableTextMemberSchemaTypes,\n  RenderAnnotationFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport {usePortableTextEditor} from '../hooks/usePortableTextEditor'\nimport {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('components:Leaf')\n\nconst EMPTY_MARKS: string[] = []\n\n/**\n * @internal\n */\nexport interface LeafProps extends RenderLeafProps {\n  editorActor: EditorActor\n  children: ReactElement<any>\n  schemaTypes: PortableTextMemberSchemaTypes\n  renderAnnotation?: RenderAnnotationFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  readOnly: boolean\n}\n\n/**\n * Renders Portable Text span nodes in Slate\n * @internal\n */\nexport const Leaf = (props: LeafProps) => {\n  const {\n    editorActor,\n    attributes,\n    children,\n    leaf,\n    schemaTypes,\n    renderChild,\n    renderDecorator,\n    renderAnnotation,\n  } = props\n  const spanRef = useRef<HTMLElement>(null)\n  const portableTextEditor = usePortableTextEditor()\n  const blockSelected = useSelected()\n  const [focused, setFocused] = useState(false)\n  const [selected, setSelected] = useState(false)\n  const block = children.props.parent as PortableTextTextBlock | undefined\n  const path: Path = useMemo(\n    () => (block ? [{_key: block?._key}, 'children', {_key: leaf._key}] : []),\n    [block, leaf._key],\n  )\n  const decoratorValues = useMemo(\n    () => schemaTypes.decorators.map((dec) => dec.value),\n    [schemaTypes.decorators],\n  )\n  const marks: string[] = useMemo(\n    () =>\n      uniq(\n        (leaf.marks || EMPTY_MARKS).filter((mark) =>\n          decoratorValues.includes(mark),\n        ),\n      ),\n    [decoratorValues, leaf.marks],\n  )\n  const annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS\n  const annotations = useMemo(\n    () =>\n      annotationMarks\n        .map(\n          (mark) =>\n            !decoratorValues.includes(mark) &&\n            block?.markDefs?.find((def) => def._key === mark),\n        )\n        .filter(Boolean) as PortableTextObject[],\n    [annotationMarks, block, decoratorValues],\n  )\n\n  const shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      setFocused(false)\n      return\n    }\n    const sel = PortableTextEditor.getSelection(portableTextEditor)\n    if (\n      sel &&\n      isEqual(sel.focus.path, path) &&\n      PortableTextEditor.isCollapsedSelection(portableTextEditor)\n    ) {\n      startTransition(() => {\n        setFocused(true)\n      })\n    }\n  }, [shouldTrackSelectionAndFocus, path, portableTextEditor])\n\n  // Function to check if this leaf is currently inside the user's text selection\n  const setSelectedFromRange = useCallback(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return\n    }\n    debug('Setting selection and focus from range')\n    const winSelection = window.getSelection()\n    if (!winSelection) {\n      setSelected(false)\n      return\n    }\n    if (winSelection && winSelection.rangeCount > 0) {\n      const range = winSelection.getRangeAt(0)\n      if (spanRef.current && range.intersectsNode(spanRef.current)) {\n        setSelected(true)\n      } else {\n        setSelected(false)\n      }\n    } else {\n      setSelected(false)\n    }\n  }, [shouldTrackSelectionAndFocus])\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return undefined\n    }\n\n    const onBlur = editorActor.on('blurred', () => {\n      setFocused(false)\n      setSelected(false)\n    })\n\n    const onFocus = editorActor.on('focused', () => {\n      const sel = PortableTextEditor.getSelection(portableTextEditor)\n      if (\n        sel &&\n        isEqual(sel.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      }\n      setSelectedFromRange()\n    })\n\n    const onSelection = editorActor.on('selection', (event) => {\n      if (\n        event.selection &&\n        isEqual(event.selection.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      } else {\n        setFocused(false)\n      }\n      setSelectedFromRange()\n    })\n\n    return () => {\n      onBlur.unsubscribe()\n      onFocus.unsubscribe()\n      onSelection.unsubscribe()\n    }\n  }, [\n    editorActor,\n    path,\n    portableTextEditor,\n    setSelectedFromRange,\n    shouldTrackSelectionAndFocus,\n  ])\n\n  useEffect(() => setSelectedFromRange(), [setSelectedFromRange])\n\n  const content = useMemo(() => {\n    let returnedChildren = children\n    // Render text nodes\n    if (Text.isText(leaf) && leaf._type === schemaTypes.span.name) {\n      marks.forEach((mark) => {\n        const schemaType = schemaTypes.decorators.find(\n          (dec) => dec.value === mark,\n        )\n        if (schemaType && renderDecorator) {\n          const _props: Omit<BlockDecoratorRenderProps, 'type'> =\n            Object.defineProperty(\n              {\n                children: returnedChildren,\n                editorElementRef: spanRef,\n                focused,\n                path,\n                selected,\n                schemaType,\n                value: mark,\n              },\n              'type',\n              {\n                enumerable: false,\n                get() {\n                  console.warn(\n                    \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                  )\n                  return schemaType\n                },\n              },\n            )\n          returnedChildren = renderDecorator(\n            _props as BlockDecoratorRenderProps,\n          )\n        }\n      })\n\n      if (block && annotations.length > 0) {\n        annotations.forEach((annotation) => {\n          const schemaType = schemaTypes.annotations.find(\n            (t) => t.name === annotation._type,\n          )\n          if (schemaType) {\n            if (renderAnnotation) {\n              const _props: Omit<BlockAnnotationRenderProps, 'type'> =\n                Object.defineProperty(\n                  {\n                    block,\n                    children: returnedChildren,\n                    editorElementRef: spanRef,\n                    focused,\n                    path,\n                    selected,\n                    schemaType,\n                    value: annotation,\n                  },\n                  'type',\n                  {\n                    enumerable: false,\n                    get() {\n                      console.warn(\n                        \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                      )\n                      return schemaType\n                    },\n                  },\n                )\n\n              returnedChildren = (\n                <span ref={spanRef}>\n                  {renderAnnotation(_props as BlockAnnotationRenderProps)}\n                </span>\n              )\n            } else {\n              returnedChildren = <span ref={spanRef}>{returnedChildren}</span>\n            }\n          }\n        })\n      }\n      if (block && renderChild) {\n        const child = block.children.find((_child) => _child._key === leaf._key) // Ensure object equality\n        if (child) {\n          const defaultRendered = <>{returnedChildren}</>\n          const _props: Omit<BlockChildRenderProps, 'type'> =\n            Object.defineProperty(\n              {\n                annotations,\n                children: defaultRendered,\n                editorElementRef: spanRef,\n                focused,\n                path,\n                schemaType: schemaTypes.span,\n                selected,\n                value: child,\n              },\n              'type',\n              {\n                enumerable: false,\n                get() {\n                  console.warn(\n                    \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                  )\n                  return schemaTypes.span\n                },\n              },\n            )\n          returnedChildren = renderChild(_props as BlockChildRenderProps)\n        }\n      }\n    }\n    return returnedChildren\n  }, [\n    annotations,\n    block,\n    children,\n    focused,\n    leaf,\n    marks,\n    path,\n    renderAnnotation,\n    renderChild,\n    renderDecorator,\n    schemaTypes.annotations,\n    schemaTypes.decorators,\n    schemaTypes.span,\n    selected,\n  ])\n  return useMemo(\n    () => (\n      <span key={leaf._key} {...attributes} ref={spanRef}>\n        {content}\n      </span>\n    ),\n    [leaf, attributes, content],\n  )\n}\n\nLeaf.displayName = 'Leaf'\n","import type {KeyboardEvent} from 'react'\nimport type {ReactEditor} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {isHotkey} from '../../internal-utils/is-hotkey'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {HotkeyOptions} from '../../types/options'\nimport type {EditorActor} from '../editor-machine'\nimport type {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('plugin:withHotKeys')\n\n/**\n * This plugin takes care of all hotkeys in the editor\n *\n */\nexport function createWithHotkeys(\n  editorActor: EditorActor,\n  portableTextEditor: PortableTextEditor,\n  hotkeysFromOptions?: HotkeyOptions,\n): (editor: PortableTextSlateEditor & ReactEditor) => any {\n  const reservedHotkeys = ['enter', 'tab', 'shift', 'delete', 'end']\n  const activeHotkeys = hotkeysFromOptions ?? {}\n  return function withHotKeys(editor: PortableTextSlateEditor & ReactEditor) {\n    editor.pteWithHotKeys = (event: KeyboardEvent<HTMLDivElement>): void => {\n      // Wire up custom marks hotkeys\n      Object.keys(activeHotkeys).forEach((cat) => {\n        if (cat === 'marks') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              event.preventDefault()\n              const possibleMark = activeHotkeys[cat]\n              if (possibleMark) {\n                const mark = possibleMark[hotkey]\n                debug(`HotKey ${hotkey} to toggle ${mark}`)\n                editorActor.send({\n                  type: 'behavior event',\n                  behaviorEvent: {\n                    type: 'decorator.toggle',\n                    decorator: mark,\n                  },\n                  editor,\n                })\n              }\n            }\n          }\n        }\n        if (cat === 'custom') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              const possibleCommand = activeHotkeys[cat]\n              if (possibleCommand) {\n                const command = possibleCommand[hotkey]\n                command(event, portableTextEditor)\n              }\n            }\n          }\n        }\n      })\n    }\n    return editor\n  }\n}\n","import {isEqual} from 'lodash'\nimport {\n  Element,\n  Path,\n  Range,\n  type BaseRange,\n  type NodeEntry,\n  type Operation,\n} from 'slate'\nimport {\n  and,\n  assign,\n  fromCallback,\n  setup,\n  type ActorRefFrom,\n  type AnyEventObject,\n  type CallbackLogicFunction,\n} from 'xstate'\nimport {moveRangeByOperation, toSlateRange} from '../internal-utils/ranges'\nimport {slateRangeToSelection} from '../internal-utils/slate-utils'\nimport {isEqualToEmptyEditor} from '../internal-utils/values'\nimport type {PortableTextSlateEditor, RangeDecoration} from '../types/editor'\nimport type {EditorSchema} from './editor-schema'\n\nconst slateOperationCallback: CallbackLogicFunction<\n  AnyEventObject,\n  {type: 'slate operation'; operation: Operation},\n  {slateEditor: PortableTextSlateEditor}\n> = ({input, sendBack}) => {\n  const originalApply = input.slateEditor.apply\n\n  input.slateEditor.apply = (op) => {\n    if (op.type !== 'set_selection') {\n      sendBack({type: 'slate operation', operation: op})\n    }\n\n    originalApply(op)\n  }\n\n  return () => {\n    input.slateEditor.apply = originalApply\n  }\n}\n\ntype DecoratedRange = BaseRange & {rangeDecoration: RangeDecoration}\n\nexport const rangeDecorationsMachine = setup({\n  types: {\n    context: {} as {\n      decoratedRanges: Array<DecoratedRange>\n      pendingRangeDecorations: Array<RangeDecoration>\n      skipSetup: boolean\n      readOnly: boolean\n      schema: EditorSchema\n      slateEditor: PortableTextSlateEditor\n      updateCount: number\n    },\n    input: {} as {\n      rangeDecorations: Array<RangeDecoration>\n      readOnly: boolean\n      schema: EditorSchema\n      skipSetup: boolean\n      slateEditor: PortableTextSlateEditor\n    },\n    events: {} as\n      | {\n          type: 'ready'\n        }\n      | {\n          type: 'range decorations updated'\n          rangeDecorations: Array<RangeDecoration>\n        }\n      | {\n          type: 'slate operation'\n          operation: Operation\n        }\n      | {\n          type: 'update read only'\n          readOnly: boolean\n        },\n  },\n  actions: {\n    'update pending range decorations': assign({\n      pendingRangeDecorations: ({context, event}) => {\n        if (event.type !== 'range decorations updated') {\n          return context.pendingRangeDecorations\n        }\n\n        return event.rangeDecorations\n      },\n    }),\n    'set up initial range decorations': assign({\n      decoratedRanges: ({context}) => {\n        const rangeDecorationState: Array<DecoratedRange> = []\n\n        for (const rangeDecoration of context.pendingRangeDecorations) {\n          const slateRange = toSlateRange(\n            rangeDecoration.selection,\n            context.slateEditor,\n          )\n\n          if (!Range.isRange(slateRange)) {\n            rangeDecoration.onMoved?.({\n              newSelection: null,\n              rangeDecoration,\n              origin: 'local',\n            })\n            continue\n          }\n\n          rangeDecorationState.push({\n            rangeDecoration,\n            ...slateRange,\n          })\n        }\n\n        return rangeDecorationState\n      },\n    }),\n    'update range decorations': assign({\n      decoratedRanges: ({context, event}) => {\n        if (event.type !== 'range decorations updated') {\n          return context.decoratedRanges\n        }\n\n        const rangeDecorationState: Array<DecoratedRange> = []\n\n        for (const rangeDecoration of event.rangeDecorations) {\n          const slateRange = toSlateRange(\n            rangeDecoration.selection,\n            context.slateEditor,\n          )\n\n          if (!Range.isRange(slateRange)) {\n            rangeDecoration.onMoved?.({\n              newSelection: null,\n              rangeDecoration,\n              origin: 'local',\n            })\n            continue\n          }\n\n          rangeDecorationState.push({\n            rangeDecoration,\n            ...slateRange,\n          })\n        }\n\n        return rangeDecorationState\n      },\n    }),\n    'move range decorations': assign({\n      decoratedRanges: ({context, event}) => {\n        if (event.type !== 'slate operation') {\n          return context.decoratedRanges\n        }\n\n        const rangeDecorationState: Array<DecoratedRange> = []\n\n        for (const decoratedRange of context.decoratedRanges) {\n          const slateRange = toSlateRange(\n            decoratedRange.rangeDecoration.selection,\n            context.slateEditor,\n          )\n\n          if (!Range.isRange(slateRange)) {\n            decoratedRange.rangeDecoration.onMoved?.({\n              newSelection: null,\n              rangeDecoration: decoratedRange.rangeDecoration,\n              origin: 'local',\n            })\n            continue\n          }\n\n          let newRange: BaseRange | null | undefined\n\n          newRange = moveRangeByOperation(slateRange, event.operation)\n          if (\n            (newRange && newRange !== slateRange) ||\n            (newRange === null && slateRange)\n          ) {\n            const newRangeSelection = newRange\n              ? slateRangeToSelection({\n                  schema: context.schema,\n                  editor: context.slateEditor,\n                  range: newRange,\n                })\n              : null\n\n            decoratedRange.rangeDecoration.onMoved?.({\n              newSelection: newRangeSelection,\n              rangeDecoration: decoratedRange.rangeDecoration,\n              origin: 'local',\n            })\n          }\n\n          // If the newRange is null, it means that the range is not valid anymore and should be removed\n          // If it's undefined, it means that the slateRange is still valid and should be kept\n          if (newRange !== null) {\n            rangeDecorationState.push({\n              ...(newRange || slateRange),\n              rangeDecoration: {\n                ...decoratedRange.rangeDecoration,\n                selection: slateRangeToSelection({\n                  schema: context.schema,\n                  editor: context.slateEditor,\n                  range: newRange,\n                }),\n              },\n            })\n          }\n        }\n\n        return rangeDecorationState\n      },\n    }),\n    'assign readOnly': assign({\n      readOnly: ({context, event}) => {\n        if (event.type !== 'update read only') {\n          return context.readOnly\n        }\n\n        return event.readOnly\n      },\n    }),\n    'increment update count': assign({\n      updateCount: ({context}) => {\n        return context.updateCount + 1\n      },\n    }),\n  },\n  actors: {\n    'slate operation listener': fromCallback(slateOperationCallback),\n  },\n  guards: {\n    'has pending range decorations': ({context}) =>\n      context.pendingRangeDecorations.length > 0,\n    'has range decorations': ({context}) => context.decoratedRanges.length > 0,\n    'has different decorations': ({context, event}) => {\n      if (event.type !== 'range decorations updated') {\n        return false\n      }\n\n      const existingRangeDecorations = context.decoratedRanges.map(\n        (decoratedRange) => ({\n          anchor: decoratedRange.rangeDecoration.selection?.anchor,\n          focus: decoratedRange.rangeDecoration.selection?.focus,\n        }),\n      )\n\n      const newRangeDecorations = event.rangeDecorations.map(\n        (rangeDecoration) => ({\n          anchor: rangeDecoration.selection?.anchor,\n          focus: rangeDecoration.selection?.focus,\n        }),\n      )\n\n      const different = !isEqual(existingRangeDecorations, newRangeDecorations)\n\n      return different\n    },\n    'not read only': ({context}) => !context.readOnly,\n    'should skip setup': ({context}) => context.skipSetup,\n  },\n}).createMachine({\n  id: 'range decorations',\n  context: ({input}) => ({\n    readOnly: input.readOnly,\n    pendingRangeDecorations: input.rangeDecorations,\n    decoratedRanges: [],\n    skipSetup: input.skipSetup,\n    schema: input.schema,\n    slateEditor: input.slateEditor,\n    updateCount: 0,\n  }),\n  invoke: {\n    src: 'slate operation listener',\n    input: ({context}) => ({slateEditor: context.slateEditor}),\n  },\n  on: {\n    'update read only': {\n      actions: ['assign readOnly'],\n    },\n  },\n  initial: 'setting up',\n  states: {\n    'setting up': {\n      always: [\n        {\n          guard: and(['should skip setup', 'has pending range decorations']),\n          target: 'ready',\n          actions: [\n            'set up initial range decorations',\n            'increment update count',\n          ],\n        },\n        {\n          guard: 'should skip setup',\n          target: 'ready',\n        },\n      ],\n      on: {\n        'range decorations updated': {\n          actions: ['update pending range decorations'],\n        },\n        'ready': [\n          {\n            target: 'ready',\n            guard: 'has pending range decorations',\n            actions: [\n              'set up initial range decorations',\n              'increment update count',\n            ],\n          },\n          {\n            target: 'ready',\n          },\n        ],\n      },\n    },\n    'ready': {\n      initial: 'idle',\n      on: {\n        'range decorations updated': {\n          target: '.idle',\n          guard: 'has different decorations',\n          actions: ['update range decorations', 'increment update count'],\n        },\n      },\n      states: {\n        'idle': {\n          on: {\n            'slate operation': {\n              target: 'moving range decorations',\n              guard: and(['has range decorations', 'not read only']),\n            },\n          },\n        },\n        'moving range decorations': {\n          entry: ['move range decorations'],\n          always: {\n            target: 'idle',\n          },\n        },\n      },\n    },\n  },\n})\n\nexport function createDecorate(\n  rangeDecorationActor: ActorRefFrom<typeof rangeDecorationsMachine>,\n) {\n  return function decorate([node, path]: NodeEntry): Array<BaseRange> {\n    if (\n      isEqualToEmptyEditor(\n        rangeDecorationActor.getSnapshot().context.slateEditor.children,\n        rangeDecorationActor.getSnapshot().context.schema,\n      )\n    ) {\n      return [\n        {\n          anchor: {\n            path: [0, 0],\n            offset: 0,\n          },\n          focus: {\n            path: [0, 0],\n            offset: 0,\n          },\n          placeholder: true,\n        } as BaseRange,\n      ]\n    }\n\n    // Editor node has a path length of 0 (should never be decorated)\n    if (path.length === 0) {\n      return []\n    }\n\n    if (!Element.isElement(node) || node.children.length === 0) {\n      return []\n    }\n\n    const blockIndex = path.at(0)\n\n    if (blockIndex === undefined) {\n      return []\n    }\n\n    return rangeDecorationActor\n      .getSnapshot()\n      .context.decoratedRanges.filter((decoratedRange) => {\n        // Special case in order to only return one decoration for collapsed ranges\n        if (Range.isCollapsed(decoratedRange)) {\n          // Collapsed ranges should only be decorated if they are on a block child level (length 2)\n          return node.children.some(\n            (_, childIndex) =>\n              Path.equals(decoratedRange.anchor.path, [\n                blockIndex,\n                childIndex,\n              ]) &&\n              Path.equals(decoratedRange.focus.path, [blockIndex, childIndex]),\n          )\n        }\n\n        return (\n          Range.intersection(decoratedRange, {\n            anchor: {path, offset: 0},\n            focus: {path, offset: 0},\n          }) || Range.includes(decoratedRange, path)\n        )\n      })\n  }\n}\n","import {useActorRef, useSelector} from '@xstate/react'\nimport {noop} from 'lodash'\nimport {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n  type ClipboardEvent,\n  type CSSProperties,\n  type FocusEventHandler,\n  type KeyboardEvent,\n  type MutableRefObject,\n  type TextareaHTMLAttributes,\n} from 'react'\nimport {Editor, Transforms, type Text} from 'slate'\nimport {\n  ReactEditor,\n  Editable as SlateEditable,\n  useSlate,\n  type RenderElementProps,\n  type RenderLeafProps,\n} from 'slate-react'\nimport {getCompoundClientRect} from '../internal-utils/compound-client-rect'\nimport {debugWithName} from '../internal-utils/debug'\nimport {getDragSelection} from '../internal-utils/drag-selection'\nimport {getEventPosition} from '../internal-utils/event-position'\nimport {parseBlocks} from '../internal-utils/parse-blocks'\nimport {toSlateRange} from '../internal-utils/ranges'\nimport {normalizeSelection} from '../internal-utils/selection'\nimport {getSelectionDomNodes} from '../internal-utils/selection-elements'\nimport {slateRangeToSelection} from '../internal-utils/slate-utils'\nimport {fromSlateValue} from '../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../internal-utils/weakMaps'\nimport * as selectors from '../selectors'\nimport type {\n  EditorSelection,\n  OnCopyFn,\n  OnPasteFn,\n  RangeDecoration,\n  RenderAnnotationFunction,\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n  RenderListItemFunction,\n  RenderPlaceholderFunction,\n  RenderStyleFunction,\n  ScrollSelectionIntoViewFunction,\n} from '../types/editor'\nimport type {HotkeyOptions} from '../types/options'\nimport {isSelectionCollapsed} from '../utils'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {Element} from './components/Element'\nimport {Leaf} from './components/Leaf'\nimport {EditorActorContext} from './editor-actor-context'\nimport {getEditorSnapshot} from './editor-selector'\nimport {usePortableTextEditor} from './hooks/usePortableTextEditor'\nimport {createWithHotkeys} from './plugins/createWithHotKeys'\nimport {PortableTextEditor} from './PortableTextEditor'\nimport {\n  createDecorate,\n  rangeDecorationsMachine,\n} from './range-decorations-machine'\n\nconst debug = debugWithName('component:Editable')\n\nconst PLACEHOLDER_STYLE: CSSProperties = {\n  position: 'absolute',\n  userSelect: 'none',\n  pointerEvents: 'none',\n  left: 0,\n  right: 0,\n}\n\n/**\n * @public\n */\nexport type PortableTextEditableProps = Omit<\n  TextareaHTMLAttributes<HTMLDivElement>,\n  'onPaste' | 'onCopy' | 'onBeforeInput'\n> & {\n  hotkeys?: HotkeyOptions\n  onBeforeInput?: (event: InputEvent) => void\n  onPaste?: OnPasteFn\n  onCopy?: OnCopyFn\n  ref: MutableRefObject<HTMLDivElement | null>\n  rangeDecorations?: RangeDecoration[]\n  renderAnnotation?: RenderAnnotationFunction\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  renderListItem?: RenderListItemFunction\n  renderPlaceholder?: RenderPlaceholderFunction\n  renderStyle?: RenderStyleFunction\n  scrollSelectionIntoView?: ScrollSelectionIntoViewFunction\n  selection?: EditorSelection\n  spellCheck?: boolean\n}\n\n/**\n * @public\n *\n *\n * The core component that renders the editor. Must be placed within the {@link EditorProvider} component.\n *\n * @example\n * ```tsx\n * import { PortableTextEditable, EditorProvider } from '@portabletext/editor'\n *\n * function MyComponent() {\n *  return (\n *   <EditorProvider>\n *    <PortableTextEditable />\n *  </EditorProvider>\n *  )\n * }\n * ```\n * @group Components\n */\nexport const PortableTextEditable = forwardRef<\n  Omit<HTMLDivElement, 'as' | 'onPaste' | 'onBeforeInput'>,\n  PortableTextEditableProps\n>(function PortableTextEditable(props, forwardedRef) {\n  const {\n    hotkeys,\n    onBlur,\n    onFocus,\n    onBeforeInput,\n    onPaste,\n    onCopy,\n    onCut,\n    onClick,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    onDragEnter,\n    onDragOver,\n    onDrop,\n    onDragLeave,\n    rangeDecorations,\n    renderAnnotation,\n    renderBlock,\n    renderChild,\n    renderDecorator,\n    renderListItem,\n    renderPlaceholder,\n    renderStyle,\n    selection: propsSelection,\n    scrollSelectionIntoView,\n    spellCheck,\n    ...restProps\n  } = props\n\n  const portableTextEditor = usePortableTextEditor()\n  const ref = useRef<HTMLDivElement | null>(null)\n  const [editableElement, setEditableElement] = useState<HTMLDivElement | null>(\n    null,\n  )\n  const [hasInvalidValue, setHasInvalidValue] = useState(false)\n\n  // Forward ref to parent component\n  useImperativeHandle<HTMLDivElement | null, HTMLDivElement | null>(\n    forwardedRef,\n    () => ref.current,\n  )\n\n  const editorActor = useContext(EditorActorContext)\n  const readOnly = useSelector(editorActor, (s) =>\n    s.matches({'edit mode': 'read only'}),\n  )\n  const slateEditor = useSlate()\n\n  const rangeDecorationsActor = useActorRef(rangeDecorationsMachine, {\n    input: {\n      rangeDecorations: rangeDecorations ?? [],\n      readOnly,\n      schema: editorActor.getSnapshot().context.schema,\n      slateEditor,\n      skipSetup: !editorActor.getSnapshot().matches({setup: 'setting up'}),\n    },\n  })\n  useSelector(rangeDecorationsActor, (s) => s.context.updateCount)\n  const decorate = useMemo(\n    () => createDecorate(rangeDecorationsActor),\n    [rangeDecorationsActor],\n  )\n\n  useEffect(() => {\n    rangeDecorationsActor.send({\n      type: 'update read only',\n      readOnly,\n    })\n  }, [rangeDecorationsActor, readOnly])\n\n  useEffect(() => {\n    rangeDecorationsActor.send({\n      type: 'range decorations updated',\n      rangeDecorations: rangeDecorations ?? [],\n    })\n  }, [rangeDecorationsActor, rangeDecorations])\n\n  // Output a minimal React editor inside Editable when in readOnly mode.\n  // NOTE: make sure all the plugins used here can be safely run over again at any point.\n  // There will be a problem if they redefine editor methods and then calling the original method within themselves.\n  useMemo(() => {\n    // React/UI-specific plugins\n    if (readOnly) {\n      debug('Editable is in read only mode')\n      return slateEditor\n    }\n    const withHotKeys = createWithHotkeys(\n      editorActor,\n      portableTextEditor,\n      hotkeys,\n    )\n\n    debug('Editable is in edit mode')\n    return withHotKeys(slateEditor)\n  }, [editorActor, hotkeys, portableTextEditor, readOnly, slateEditor])\n\n  const renderElement = useCallback(\n    (eProps: RenderElementProps) => (\n      <Element\n        {...eProps}\n        readOnly={readOnly}\n        renderBlock={renderBlock}\n        renderChild={renderChild}\n        renderListItem={renderListItem}\n        renderStyle={renderStyle}\n        schemaTypes={portableTextEditor.schemaTypes}\n        spellCheck={spellCheck}\n      />\n    ),\n    [\n      portableTextEditor,\n      spellCheck,\n      readOnly,\n      renderBlock,\n      renderChild,\n      renderListItem,\n      renderStyle,\n    ],\n  )\n\n  const renderLeaf = useCallback(\n    (\n      lProps: RenderLeafProps & {\n        leaf: Text & {placeholder?: boolean; rangeDecoration?: RangeDecoration}\n      },\n    ) => {\n      if (lProps.leaf._type === 'span') {\n        let rendered = (\n          <Leaf\n            {...lProps}\n            editorActor={editorActor}\n            schemaTypes={portableTextEditor.schemaTypes}\n            renderAnnotation={renderAnnotation}\n            renderChild={renderChild}\n            renderDecorator={renderDecorator}\n            readOnly={readOnly}\n          />\n        )\n        if (\n          renderPlaceholder &&\n          lProps.leaf.placeholder &&\n          lProps.text.text === ''\n        ) {\n          return (\n            <>\n              <span style={PLACEHOLDER_STYLE} contentEditable={false}>\n                {renderPlaceholder()}\n              </span>\n              {rendered}\n            </>\n          )\n        }\n        const decoration = lProps.leaf.rangeDecoration\n        if (decoration) {\n          rendered = decoration.component({children: rendered})\n        }\n        return rendered\n      }\n      return lProps.children\n    },\n    [\n      editorActor,\n      portableTextEditor,\n      readOnly,\n      renderAnnotation,\n      renderChild,\n      renderDecorator,\n      renderPlaceholder,\n    ],\n  )\n\n  const restoreSelectionFromProps = useCallback(() => {\n    if (propsSelection) {\n      debug(`Selection from props ${JSON.stringify(propsSelection)}`)\n      const normalizedSelection = normalizeSelection(\n        propsSelection,\n        fromSlateValue(\n          slateEditor.children,\n          editorActor.getSnapshot().context.schema.block.name,\n        ),\n      )\n      if (normalizedSelection !== null) {\n        debug(\n          `Normalized selection from props ${JSON.stringify(normalizedSelection)}`,\n        )\n        const slateRange = toSlateRange(normalizedSelection, slateEditor)\n        if (slateRange) {\n          Transforms.select(slateEditor, slateRange)\n          // Output selection here in those cases where the editor selection was the same, and there are no set_selection operations made.\n          // The selection is usually automatically emitted to change$ by the withPortableTextSelections plugin whenever there is a set_selection operation applied.\n          if (!slateEditor.operations.some((o) => o.type === 'set_selection')) {\n            editorActor.send({\n              type: 'notify.selection',\n              selection: normalizedSelection,\n            })\n          }\n          slateEditor.onChange()\n        }\n      }\n    }\n  }, [editorActor, propsSelection, slateEditor])\n\n  // Restore selection from props when the editor has been initialized properly with it's value\n  useEffect(() => {\n    const onReady = editorActor.on('ready', () => {\n      rangeDecorationsActor.send({\n        type: 'ready',\n      })\n\n      restoreSelectionFromProps()\n    })\n\n    const onInvalidValue = editorActor.on('invalid value', () => {\n      setHasInvalidValue(true)\n    })\n\n    const onValueChanged = editorActor.on('value changed', () => {\n      setHasInvalidValue(false)\n    })\n\n    return () => {\n      onReady.unsubscribe()\n      onInvalidValue.unsubscribe()\n      onValueChanged.unsubscribe()\n    }\n  }, [rangeDecorationsActor, editorActor, restoreSelectionFromProps])\n\n  // Restore selection from props when it changes\n  useEffect(() => {\n    if (propsSelection && !hasInvalidValue) {\n      restoreSelectionFromProps()\n    }\n  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps])\n\n  // Handle from props onCopy function\n  const handleCopy = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): void | ReactEditor => {\n      if (onCopy) {\n        const result = onCopy(event)\n        // CopyFn may return something to avoid doing default stuff\n        if (result !== undefined) {\n          event.preventDefault()\n        }\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n        event.preventDefault()\n\n        const selection = slateEditor.selection\n          ? slateRangeToSelection({\n              schema: editorActor.getSnapshot().context.schema,\n              editor: slateEditor,\n              range: slateEditor.selection,\n            })\n          : undefined\n        const position = selection ? {selection} : undefined\n\n        if (!position) {\n          console.warn('Could not find position for copy event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.copy',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onCopy, editorActor, slateEditor],\n  )\n\n  const handleCut = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>) => {\n      if (onCut) {\n        const result = onCut(event)\n        // CutFn may return something to avoid doing default stuff\n        if (result !== undefined) {\n          event.preventDefault()\n        }\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n        event.preventDefault()\n\n        const selection = editorActor.getSnapshot().context.selection\n        const position = selection ? {selection} : undefined\n\n        if (!position) {\n          console.warn('Could not find position for cut event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.cut',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onCut, editorActor, slateEditor],\n  )\n\n  // Handle incoming pasting events in the editor\n  const handlePaste = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): Promise<void> | void => {\n      const value = fromSlateValue(\n        slateEditor.children,\n        editorActor.getSnapshot().context.schema.block.name,\n        KEY_TO_VALUE_ELEMENT.get(slateEditor),\n      )\n      const ptRange = slateEditor.selection\n        ? slateRangeToSelection({\n            schema: editorActor.getSnapshot().context.schema,\n            editor: slateEditor,\n            range: slateEditor.selection,\n          })\n        : null\n      const path = ptRange?.focus.path || []\n      const onPasteResult = onPaste?.({\n        event,\n        value,\n        path,\n        schemaTypes: portableTextEditor.schemaTypes,\n      })\n\n      if (onPasteResult || !slateEditor.selection) {\n        event.preventDefault()\n\n        // Resolve it as promise (can be either async promise or sync return value)\n        editorActor.send({type: 'notify.loading'})\n\n        Promise.resolve(onPasteResult)\n          .then((result) => {\n            debug('Custom paste function from client resolved', result)\n\n            if (!result || !result.insert) {\n              debug('No result from custom paste handler, pasting normally')\n\n              const selection = editorActor.getSnapshot().context.selection\n              const position = selection ? {selection} : undefined\n\n              if (!position) {\n                console.warn('Could not find position for paste event')\n                return\n              }\n\n              editorActor.send({\n                type: 'behavior event',\n                behaviorEvent: {\n                  type: 'clipboard.paste',\n                  originEvent: {\n                    dataTransfer: event.clipboardData,\n                  },\n                  position,\n                },\n                editor: slateEditor,\n                nativeEvent: event,\n              })\n            } else if (result.insert) {\n              editorActor.send({\n                type: 'behavior event',\n                behaviorEvent: {\n                  type: 'insert.blocks',\n                  blocks: parseBlocks({\n                    context: {\n                      keyGenerator:\n                        editorActor.getSnapshot().context.keyGenerator,\n                      schema: editorActor.getSnapshot().context.schema,\n                    },\n                    blocks: result.insert,\n                    options: {\n                      refreshKeys: true,\n                    },\n                  }),\n                  placement: 'auto',\n                },\n                editor: slateEditor,\n              })\n            } else {\n              console.warn(\n                'Your onPaste function returned something unexpected:',\n                result,\n              )\n            }\n          })\n          .catch((error) => {\n            console.warn(error)\n\n            return error\n          })\n          .finally(() => {\n            editorActor.send({type: 'notify.done loading'})\n          })\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.preventDefault()\n        event.stopPropagation()\n\n        const selection = editorActor.getSnapshot().context.selection\n        const position = selection ? {selection} : undefined\n\n        if (!position) {\n          console.warn('Could not find position for paste event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.paste',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n\n      debug('No result from custom paste handler, pasting normally')\n    },\n    [editorActor, onPaste, portableTextEditor, slateEditor],\n  )\n\n  const handleOnFocus: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onFocus) {\n        onFocus(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        const selection = PortableTextEditor.getSelection(portableTextEditor)\n        // Create an editor selection if it does'nt exist\n        if (selection === null) {\n          Transforms.select(slateEditor, Editor.start(slateEditor, []))\n          slateEditor.onChange()\n        }\n        editorActor.send({type: 'notify.focused', event})\n        const newSelection = PortableTextEditor.getSelection(portableTextEditor)\n        // If the selection is the same, emit it explicitly here as there is no actual onChange event triggered.\n        if (selection === newSelection) {\n          editorActor.send({\n            type: 'notify.selection',\n            selection,\n          })\n        }\n      }\n    },\n    [editorActor, onFocus, slateEditor, portableTextEditor],\n  )\n\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n      if (onClick) {\n        onClick(event)\n      }\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (position) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'mouse.click',\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onClick, editorActor, slateEditor],\n  )\n\n  const handleOnBlur: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onBlur) {\n        onBlur(event)\n      }\n      if (!event.isPropagationStopped()) {\n        editorActor.send({type: 'notify.blurred', event})\n      }\n    },\n    [editorActor, onBlur],\n  )\n\n  const handleOnBeforeInput = useCallback(\n    (event: InputEvent) => {\n      if (onBeforeInput) {\n        onBeforeInput(event)\n      }\n    },\n    [onBeforeInput],\n  )\n\n  // This function will handle unexpected DOM changes inside the Editable rendering,\n  // and make sure that we can maintain a stable slateEditor.selection when that happens.\n  //\n  // For example, if this Editable is rendered inside something that might re-render\n  // this component (hidden contexts) while the user is still actively changing the\n  // contentEditable, this could interfere with the intermediate DOM selection,\n  // which again could be picked up by ReactEditor's event listeners.\n  // If that range is invalid at that point, the slate.editorSelection could be\n  // set either wrong, or invalid, to which slateEditor will throw exceptions\n  // that are impossible to recover properly from or result in a wrong selection.\n  //\n  // Also the other way around, when the ReactEditor will try to create a DOM Range\n  // from the current slateEditor.selection, it may throw unrecoverable errors\n  // if the current editor.selection is invalid according to the DOM.\n  // If this is the case, default to selecting the top of the document, if the\n  // user already had a selection.\n  const validateSelection = useCallback(() => {\n    if (!slateEditor.selection) {\n      return\n    }\n    const root = ReactEditor.findDocumentOrShadowRoot(slateEditor)\n    const {activeElement} = root\n    // Return if the editor isn't the active element\n    if (ref.current !== activeElement) {\n      return\n    }\n    const window = ReactEditor.getWindow(slateEditor)\n    const domSelection = window.getSelection()\n    if (!domSelection || domSelection.rangeCount === 0) {\n      return\n    }\n    const existingDOMRange = domSelection.getRangeAt(0)\n    try {\n      const newDOMRange = ReactEditor.toDOMRange(\n        slateEditor,\n        slateEditor.selection,\n      )\n      if (\n        newDOMRange.startOffset !== existingDOMRange.startOffset ||\n        newDOMRange.endOffset !== existingDOMRange.endOffset\n      ) {\n        debug('DOM range out of sync, validating selection')\n        // Remove all ranges temporary\n        domSelection?.removeAllRanges()\n        // Set the correct range\n        domSelection.addRange(newDOMRange)\n      }\n    } catch {\n      debug(`Could not resolve selection, selecting top document`)\n      // Deselect the editor\n      Transforms.deselect(slateEditor)\n      // Select top document if there is a top block to select\n      if (slateEditor.children.length > 0) {\n        Transforms.select(slateEditor, [0, 0])\n      }\n      slateEditor.onChange()\n    }\n  }, [ref, slateEditor])\n\n  // Observe mutations (child list and subtree) to this component's DOM,\n  // and make sure the editor selection is valid when that happens.\n  useEffect(() => {\n    if (editableElement) {\n      const mutationObserver = new MutationObserver(validateSelection)\n      mutationObserver.observe(editableElement, {\n        attributeOldValue: false,\n        attributes: false,\n        characterData: false,\n        childList: true,\n        subtree: true,\n      })\n      return () => {\n        mutationObserver.disconnect()\n      }\n    }\n    return undefined\n  }, [validateSelection, editableElement])\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyDown) {\n        props.onKeyDown(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        slateEditor.pteWithHotKeys(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'keyboard.keydown',\n            originEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const handleKeyUp = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyUp) {\n        props.onKeyUp(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'keyboard.keyup',\n            originEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const scrollSelectionIntoViewToSlate = useMemo(() => {\n    // Use slate-react default scroll into view\n    if (scrollSelectionIntoView === undefined) {\n      return undefined\n    }\n    // Disable scroll into view totally\n    if (scrollSelectionIntoView === null) {\n      return noop\n    }\n    // Translate PortableTextEditor prop fn to Slate plugin fn\n    return (_editor: ReactEditor, domRange: Range) => {\n      scrollSelectionIntoView(portableTextEditor, domRange)\n    }\n  }, [portableTextEditor, scrollSelectionIntoView])\n\n  // Set the forwarded ref to be the Slate editable DOM element\n  // Also set the editable element in a state so that the MutationObserver\n  // is setup when this element is ready.\n  useEffect(() => {\n    ref.current = ReactEditor.toDOMNode(\n      slateEditor,\n      slateEditor,\n    ) as HTMLDivElement | null\n    setEditableElement(ref.current)\n  }, [slateEditor, ref])\n\n  useEffect(() => {\n    const window = ReactEditor.getWindow(slateEditor)\n\n    const onDragEnd = () => {\n      editorActor.send({type: 'dragend'})\n    }\n    const onDrop = () => {\n      editorActor.send({type: 'drop'})\n    }\n\n    window.document.addEventListener('dragend', onDragEnd)\n    window.document.addEventListener('drop', onDrop)\n\n    return () => {\n      window.document.removeEventListener('dragend', onDragEnd)\n      window.document.removeEventListener('drop', onDrop)\n    }\n  }, [slateEditor, editorActor])\n\n  const handleDragStart = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragStart?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        console.warn('Could not find position for dragstart event')\n        return\n      }\n\n      const snapshot = getEditorSnapshot({\n        editorActorSnapshot: editorActor.getSnapshot(),\n        slateEditorInstance: slateEditor,\n      })\n      const dragSelection = getDragSelection({\n        eventSelection: position.selection,\n        snapshot,\n      })\n\n      const selectingEntireBlocks = selectors.isSelectingEntireBlocks({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: dragSelection,\n        },\n      })\n\n      const dragGhost = document.createElement('div')\n\n      const draggedDomNodes = getSelectionDomNodes({\n        snapshot: {\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragSelection,\n          },\n        },\n        slateEditor,\n      })\n\n      if (selectingEntireBlocks) {\n        // Clone the DOM Nodes so they won't be visually clipped by scroll-containers etc.\n        const clonedBlockNodes = draggedDomNodes.blockNodes.map((node) =>\n          node.cloneNode(true),\n        )\n\n        for (const block of clonedBlockNodes) {\n          if (block instanceof HTMLElement) {\n            block.style.position = 'relative'\n          }\n          dragGhost.appendChild(block)\n        }\n\n        // A custom drag ghost element can be configured using this data attribute\n        const customGhost = dragGhost.querySelector(\n          '[data-pt-drag-ghost-element]',\n        )\n        if (customGhost) {\n          dragGhost.replaceChildren(customGhost)\n        }\n\n        // Setting the `data-dragged` attribute so the consumer can style the element while its dragged\n        dragGhost.setAttribute('data-dragged', '')\n\n        dragGhost.style.position = 'absolute'\n        dragGhost.style.left = '-99999px'\n        dragGhost.style.boxSizing = 'border-box'\n        document.body.appendChild(dragGhost)\n\n        if (customGhost) {\n          const customGhostRect = customGhost.getBoundingClientRect()\n          const x = event.clientX - customGhostRect.left\n          const y = event.clientY - customGhostRect.top\n          dragGhost.style.width = `${customGhostRect.width}px`\n          dragGhost.style.height = `${customGhostRect.height}px`\n          event.dataTransfer.setDragImage(dragGhost, x, y)\n        } else {\n          const blocksDomRect = getCompoundClientRect(\n            draggedDomNodes.blockNodes,\n          )\n          const x = event.clientX - blocksDomRect.left\n          const y = event.clientY - blocksDomRect.top\n          dragGhost.style.width = `${blocksDomRect.width}px`\n          dragGhost.style.height = `${blocksDomRect.height}px`\n          event.dataTransfer.setDragImage(dragGhost, x, y)\n        }\n      } else {\n        const clonedChildNodes = draggedDomNodes.childNodes.map((node) =>\n          node.cloneNode(true),\n        )\n\n        for (const child of clonedChildNodes) {\n          dragGhost.appendChild(child)\n        }\n\n        dragGhost.style.position = 'absolute'\n        dragGhost.style.left = '-99999px'\n        dragGhost.style.boxSizing = 'border-box'\n        document.body.appendChild(dragGhost)\n\n        const childrenDomRect = getCompoundClientRect(\n          draggedDomNodes.childNodes,\n        )\n        const x = event.clientX - childrenDomRect.left\n        const y = event.clientY - childrenDomRect.top\n        dragGhost.style.width = `${childrenDomRect.width}px`\n        dragGhost.style.height = `${childrenDomRect.height}px`\n\n        event.dataTransfer.setDragImage(dragGhost, x, y)\n      }\n\n      // Select drag selection\n      // If the selection is expanded then we just select the end of the\n      // selection\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'select',\n          at: isSelectionCollapsed(dragSelection)\n            ? dragSelection\n            : {\n                anchor: getSelectionEndPoint(dragSelection),\n                focus: getSelectionEndPoint(dragSelection),\n                backward: false,\n              },\n        },\n        editor: slateEditor,\n      })\n\n      editorActor.send({\n        type: 'dragstart',\n        origin: {\n          selection: dragSelection,\n        },\n        ghost: dragGhost,\n      })\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragstart',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position: {\n            selection: dragSelection,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragStart, editorActor, slateEditor],\n  )\n\n  const handleDrag = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDrag?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.drag',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDrag, editorActor, slateEditor],\n  )\n\n  const handleDragEnd = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragEnd?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragend',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragEnd, editorActor, slateEditor],\n  )\n\n  const handleDragEnter = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragEnter?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragenter',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position,\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragEnter, editorActor, slateEditor],\n  )\n\n  const handleDragOver = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragOver?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragover',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position,\n        },\n        editor: slateEditor,\n        nativeEvent: event,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragOver, editorActor, slateEditor],\n  )\n\n  const handleDrop = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDrop?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        console.warn('Could not find position for drop event')\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.drop',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position,\n        },\n        editor: slateEditor,\n        nativeEvent: event,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDrop, editorActor, slateEditor],\n  )\n\n  const handleDragLeave = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragLeave?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragleave',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragLeave, editorActor, slateEditor],\n  )\n\n  if (!portableTextEditor) {\n    return null\n  }\n\n  return hasInvalidValue ? null : (\n    <SlateEditable\n      {...restProps}\n      autoFocus={false}\n      className={restProps.className || 'pt-editable'}\n      decorate={decorate}\n      onBlur={handleOnBlur}\n      onCopy={handleCopy}\n      onCut={handleCut}\n      onClick={handleClick}\n      onDOMBeforeInput={handleOnBeforeInput}\n      onDragStart={handleDragStart}\n      onDrag={handleDrag}\n      onDragEnd={handleDragEnd}\n      onDragEnter={handleDragEnter}\n      onDragOver={handleDragOver}\n      onDrop={handleDrop}\n      onDragLeave={handleDragLeave}\n      onFocus={handleOnFocus}\n      onKeyDown={handleKeyDown}\n      onKeyUp={handleKeyUp}\n      onPaste={handlePaste}\n      readOnly={readOnly}\n      // We have implemented our own placeholder logic with decorations.\n      // This 'renderPlaceholder' should not be used.\n      renderPlaceholder={undefined}\n      renderElement={renderElement}\n      renderLeaf={renderLeaf}\n      scrollSelectionIntoView={scrollSelectionIntoViewToSlate}\n    />\n  )\n})\n\nPortableTextEditable.displayName = 'ForwardRef(PortableTextEditable)'\n"],"names":["EditorEventListener","props","$","_c","editor","useEditor","on","useEffectEvent","t0","subscription","unsubscribe","t1","useEffect","getCompoundClientRect","nodes","length","DOMRect","elements","filter","node","Element","firstRect","at","getBoundingClientRect","left","top","right","bottom","i","rect","Math","min","max","getDragSelection","eventSelection","snapshot","dragSelection","selectors","context","selection","draggingCollapsedSelection","draggedTextBlock","draggedSpan","anchor","utils","getBlockStartPoint","focus","getBlockEndPoint","selectedBlocks","getSelectedBlocks","selectionStartBlock","selectionEndBlock","selectionStartPoint","selectionEndPoint","getEventPosition","editorActor","slateEditor","event","getSnapshot","matches","setup","getEventNode","block","getNodeBlock","schema","positionBlock","getEventPositionBlock","getEventSelection","Editor","isEditor","path","_key","focusBlockPath","focusBlockKey","undefined","DOMEditor","hasTarget","target","toSlateNode","firstBlock","getFirstBlock","firstBlockRect","toDOMNode","pageY","lastBlock","getLastBlock","lastBlockRef","elementRect","height","abs","range","getSlateRangeFromEvent","slateRangeToSelection","isDOMNode","window","getWindow","domRange","document","caretPositionFromPoint","position","clientX","clientY","createRange","setStart","offsetNode","offset","setEnd","caretRangeFromPoint","console","warn","toSlateRange","exactMatch","suppressThrow","normalizePoint","point","value","newPath","newOffset","blockKey","childKey","find","blk","push","children","Array","isArray","child","cld","text","normalizeSelection","newAnchor","newFocus","isEqual","backward","getSelectionDomNodes","blockNodes","childNodes","blockEntries","from","mode","match","n","childEntries","isTextSpan","isBlock","map","blockNode","childNode","DefaultBlockObject","Symbol","for","userSelect","_type","jsxs","DefaultInlineObject","DropIndicator","jsx","width","borderBottom","zIndex","debugWithName","EMPTY_ANNOTATIONS","inlineBlockStyle","display","attributes","element","schemaTypes","readOnly","renderBlock","renderChild","renderListItem","renderStyle","spellCheck","useContext","EditorActorContext","useSlateStatic","selected","useSelected","blockRef","useRef","inlineBlockObjectRef","focused","Range","isCollapsed","dragPositionBlock","setDragPositionBlock","useState","behavior","defineBehavior","guard","dropFocusBlock","dragOrigin","beta","internalDrag","origin","some","draggedBlock","actions","type","effect","send","useMemo","fromSlateValue","name","KEY_TO_VALUE_ELEMENT","get","renderedBlock","className","blockPath","Error","isInline","ReactEditor","findPath","depth","schemaType","inlineObjects","SlateElement","isElement","elmPath","debugRenders","annotations","editorElementRef","isListItem","style","blockStyleType","styles","item","level","listItem","isListBlock","listType","lists","renderProps","Object","defineProperty","enumerable","propsOrDefaultRendered","blockObjects","renderedBlockFromProps","_props","displayName","debug","EMPTY_MARKS","Leaf","leaf","renderDecorator","renderAnnotation","spanRef","portableTextEditor","usePortableTextEditor","blockSelected","setFocused","setSelected","parent","decoratorValues","decorators","dec","marks","uniq","mark","includes","annotationMarks","markDefs","def","Boolean","shouldTrackSelectionAndFocus","sel","PortableTextEditor","getSelection","isCollapsedSelection","startTransition","setSelectedFromRange","useCallback","winSelection","rangeCount","getRangeAt","current","intersectsNode","onBlur","onFocus","onSelection","content","returnedChildren","Text","isText","span","forEach","annotation","t","_child","createWithHotkeys","hotkeysFromOptions","reservedHotkeys","activeHotkeys","pteWithHotKeys","keys","cat","hotkey","isHotkey","nativeEvent","preventDefault","possibleMark","behaviorEvent","decorator","possibleCommand","command","slateOperationCallback","input","sendBack","originalApply","apply","op","operation","rangeDecorationsMachine","types","events","assign","pendingRangeDecorations","rangeDecorations","decoratedRanges","rangeDecorationState","rangeDecoration","slateRange","isRange","onMoved","newSelection","decoratedRange","newRange","moveRangeByOperation","newRangeSelection","updateCount","actors","fromCallback","guards","has pending range decorations","has range decorations","has different decorations","existingRangeDecorations","newRangeDecorations","not read only","should skip setup","skipSetup","createMachine","id","invoke","src","initial","states","always","and","entry","createDecorate","rangeDecorationActor","isEqualToEmptyEditor","placeholder","blockIndex","_","childIndex","Path","equals","intersection","PLACEHOLDER_STYLE","pointerEvents","PortableTextEditable","forwardRef","forwardedRef","hotkeys","onBeforeInput","onPaste","onCopy","onCut","onClick","onDragStart","onDrag","onDragEnd","onDragEnter","onDragOver","onDrop","onDragLeave","renderPlaceholder","propsSelection","scrollSelectionIntoView","restProps","ref","editableElement","setEditableElement","hasInvalidValue","setHasInvalidValue","useSelector","s","useSlate","rangeDecorationsActor","useActorRef","decorate","withHotKeys","renderElement","eProps","renderLeaf","lProps","rendered","Fragment","decoration","component","restoreSelectionFromProps","JSON","stringify","normalizedSelection","Transforms","select","operations","o","onChange","onReady","onInvalidValue","onValueChanged","handleCopy","clipboardData","stopPropagation","originEvent","dataTransfer","handleCut","handlePaste","onPasteResult","Promise","resolve","then","result","insert","blocks","parseBlocks","keyGenerator","options","refreshKeys","placement","catch","error","finally","handleOnFocus","isDefaultPrevented","start","handleClick","isPropagationStopped","handleOnBlur","handleOnBeforeInput","validateSelection","root","findDocumentOrShadowRoot","activeElement","domSelection","existingDOMRange","newDOMRange","toDOMRange","startOffset","endOffset","removeAllRanges","addRange","deselect","mutationObserver","MutationObserver","observe","attributeOldValue","characterData","childList","subtree","disconnect","handleKeyDown","onKeyDown","key","code","altKey","ctrlKey","metaKey","shiftKey","handleKeyUp","onKeyUp","scrollSelectionIntoViewToSlate","noop","_editor","addEventListener","removeEventListener","handleDragStart","getEditorSnapshot","editorActorSnapshot","slateEditorInstance","selectingEntireBlocks","dragGhost","createElement","draggedDomNodes","clonedBlockNodes","cloneNode","HTMLElement","appendChild","customGhost","querySelector","replaceChildren","setAttribute","boxSizing","body","customGhostRect","x","y","setDragImage","blocksDomRect","clonedChildNodes","childrenDomRect","isSelectionCollapsed","getSelectionEndPoint","ghost","handleDrag","handleDragEnd","handleDragEnter","handleDragOver","handleDrop","handleDragLeave","SlateEditable"],"mappings":"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"}