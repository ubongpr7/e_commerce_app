{"version":3,"file":"readModuleVersion.js","sources":["../../src/_internal/cli/util/readPackageManifest.ts","../../src/_internal/cli/util/readModuleVersion.ts"],"sourcesContent":["import {readFile} from 'node:fs/promises'\n\nimport {type PackageJson} from '@sanity/cli'\n\ninterface DependencyDeclarations {\n  dependencies: Record<string, string | undefined>\n  devDependencies: Record<string, string | undefined>\n}\n\ninterface PackageManifest extends DependencyDeclarations {\n  name: string\n  version: string\n}\n\nexport interface PartialPackageManifest extends Partial<DependencyDeclarations> {\n  name: string\n  version: string\n}\n\nfunction isPackageManifest(item: unknown): item is PartialPackageManifest {\n  return typeof item === 'object' && item !== null && 'name' in item && 'version' in item\n}\n\n/**\n * Read the `package.json` file at the given path\n *\n * @param filePath - Path to package.json to read\n * @returns The parsed package.json\n */\nasync function readPackageJson(filePath: string): Promise<PackageJson> {\n  return JSON.parse(await readFile(filePath, 'utf8'))\n}\n/**\n * Read the `package.json` file at the given path and return an object that guarantees\n * the presence of name, version, dependencies, dev dependencies and peer dependencies\n *\n * @param packageJsonPath - Path to package.json to read\n * @returns Reduced package.json with guarantees for name, version and dependency fields\n */\nexport async function readPackageManifest(\n  packageJsonPath: string,\n  defaults: Partial<PartialPackageManifest> = {},\n): Promise<PackageManifest> {\n  let manifest: unknown\n  try {\n    manifest = {...defaults, ...(await readPackageJson(packageJsonPath))}\n  } catch (err) {\n    throw new Error(`Failed to read \"${packageJsonPath}\": ${err.message}`)\n  }\n\n  if (!isPackageManifest(manifest)) {\n    throw new Error(`Failed to read \"${packageJsonPath}\": Invalid package manifest`)\n  }\n\n  const {name, version, dependencies = {}, devDependencies = {}} = manifest\n  return {name, version, dependencies, devDependencies}\n}\n","import path from 'node:path'\n\nimport resolveFrom from 'resolve-from'\n\nimport {readPackageManifest} from './readPackageManifest'\n\n/**\n * Reads the version number of the _installed_ module, or returns `null` if not found\n *\n * @param dir - Path of the directory to read the module from\n * @param moduleName - Name of module to get installed version for\n * @returns Version number, of null\n */\nexport async function readModuleVersion(dir: string, moduleName: string): Promise<string | null> {\n  const manifestPath = resolveFrom.silent(dir, path.join(moduleName, 'package.json'))\n  return manifestPath ? (await readPackageManifest(manifestPath)).version : null\n}\n"],"names":["isPackageManifest","item","readPackageJson","filePath","JSON","parse","readFile","readPackageManifest","packageJsonPath","defaults","manifest","err","Error","message","name","version","dependencies","devDependencies","readModuleVersion","dir","moduleName","manifestPath","resolveFrom","silent","path","join"],"mappings":";;;;;;AAmBA,SAASA,kBAAkBC,MAA+C;AACxE,SAAO,OAAOA,QAAS,YAAYA,SAAS,QAAQ,UAAUA,QAAQ,aAAaA;AACrF;AAQA,eAAeC,gBAAgBC,UAAwC;AACrE,SAAOC,KAAKC,MAAM,MAAMC,GAASH,SAAAA,UAAU,MAAM,CAAC;AACpD;AAQA,eAAsBI,oBACpBC,iBACAC,WAA4C,IAClB;AACtBC,MAAAA;AACA,MAAA;AACS,eAAA;AAAA,MAAC,GAAGD;AAAAA,MAAU,GAAI,MAAMP,gBAAgBM,eAAe;AAAA,IAAE;AAAA,WAC7DG,KAAK;AACZ,UAAM,IAAIC,MAAM,mBAAmBJ,eAAe,MAAMG,IAAIE,OAAO,EAAE;AAAA,EAAA;AAGnE,MAAA,CAACb,kBAAkBU,QAAQ;AAC7B,UAAM,IAAIE,MAAM,mBAAmBJ,eAAe,6BAA6B;AAG3E,QAAA;AAAA,IAACM;AAAAA,IAAMC;AAAAA,IAASC,eAAe,CAAC;AAAA,IAAGC,kBAAkB,CAAA;AAAA,EAAC,IAAKP;AAC1D,SAAA;AAAA,IAACI;AAAAA,IAAMC;AAAAA,IAASC;AAAAA,IAAcC;AAAAA,EAAe;AACtD;AC3CsBC,eAAAA,kBAAkBC,KAAaC,YAA4C;AACzFC,QAAAA,eAAeC,6BAAYC,OAAOJ,KAAKK,cAAAA,QAAKC,KAAKL,YAAY,cAAc,CAAC;AAClF,SAAOC,gBAAgB,MAAMd,oBAAoBc,YAAY,GAAGN,UAAU;AAC5E;;;"}